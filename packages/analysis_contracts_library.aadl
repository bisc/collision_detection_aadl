-- this is a collection of analysis contracts for the autonomous vehicle system
package contracts_library
public  
with Sensor_Properties, Reliability_Properties, Security_Properties, Control_Properties; 

annex contract {**
	
	-- Failure Modes and Effects Analysis creates a redundancy structure tolerant random failures.  
	name FMEA
	input 
			sensor.Pfail, system.AlphaFail 
	output 
			sensor, system -- in this case system is both a mode and a controller (which is a subsystem in this model)
			-- TODO create a separate type for a controller
			
	assumes -- "Component failure independence: if one component fails, another component is not more likely to fail."
			-- sensor version
			forall s1: sensor, s2: sensor : P(!s1.Avail || s2.Avail) <= P(!s1.Avail) + EpsilonFail  
	assumes -- controller version
			forall c1: system, c2: system : P(!c1.Avail || c2.Avail) <= P(!c1.Avail) + EpsilonFail
			-- TODO create rigorous syntax for probabilistic statements
	
	guarantees -- "Functioning controllers: some sensor provides each variable that some controller expects."
		--	forall m:system : 					-- system/mode
		--	exists c:system : m.contains(c) ->   -- controller
		--	forall v:Variable : in (v, c.VarsR) ->  -- variable	
			exists s:sensor : m.contains(s) && s.VarsS.contains(v) --sensor
	
	-- analyzes the trustworthiness of sensors in a given security context
	name TrustworthinessAnalysis 
	input 
			sensor, sensor.Placement, sensor.Pow, system.Pow, sensor.Avail, system.Avail, system.AttackM 
	output
			sensor.Trust
	assumes --"Component failure dependence – some components are likely to fail together."
			-- sensor version
			exists s1: sensor, s2: sensor : P(!s1.Avail || s2.Avail) <= P(!s1.Avail) - EpsilonFail
	assumes 
			-- controller version
			exists c1: system, c2: system: P(!c1.Avail || c2.Avail) <= P(!c1.Avail) - EpsilonFail
	guarantees -- "Correct trustworthiness assignment – a sensor is not trustworthy if and only if it is vulnerable for the considered attacker model."
			forall m: system, s: sensor : m.contains(s) && !s.Trust -> m.AttackM.IsVuln(s)
			
	-- verifies if the control meets the safety requirements
	name ControlSafetyAnalysis
	input 
			sensor, sensor.VarS, system, system.VarR
	output
			system.CtrlSafe
	assumes -- "Minimal sensor trust – for each untrusted sensor there is at least one different trusted sensor."
			-- forall m: system, c: system, v: Variable : m.contains(c) && c.VarsR.contains(v) -> 
			-- exists fu: fun_sensor_sensor : 
			-- forall su: sensor : su.Vars.contains(v) && !su.Trust -> 
			-- exists st: sensor : m.contains(st) && st.Vars.contains(v) && st.Trust && f(st) = su
			true
			
			-- TODO: create rigorous syntax for function quantification. 
**};

end contracts_library; 